public class Main {

    // Warm-up problem. Interview scheduling. You can solve with either tabulation or
    // memoization (if doing memoization, make a separate function to recur)
    // See instructions on Canvas. Implementing latestNonOverlapping is recommended.
    // For your convenience, the intervals will be sorted by end time.
    public static int weightedInterviewScheduling(WeightedInterval[] intervals) {
        return -1;
    }

    // Return the index of the last (rightmost) interval that finishes
    // before the interval with index ind
    // The method should return -1 if there is no such interval
    public static int latestNonOverlapping(WeightedInterval[] intervals, int ind) {
        return -1;
    }

    // Given a matrix, returns the sum of the minimum "falling path" through
    // the matrix.
    // A falling path starts at any element in the first row, then moves either down left,
    // down, or down right. It repeats, going any of those three directions, until it reaches
    // the bottom. See Canvas for a more detailed description
    public int minFallingPathSum(int[][] matrix) {
        return -1;
    }


}
